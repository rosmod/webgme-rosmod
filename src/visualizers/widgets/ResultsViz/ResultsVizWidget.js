/*globals define, WebGMEGlobal*/
/*jshint browser: true*/

/**
 * Generated by VisualizerGenerator 0.1.0 from webgme on Wed Apr 06 2016 14:15:27 GMT-0500 (CDT).
 */

define([
    'text!./Plot.html',
    'blob/BlobClient',
    './ResultsVizWidget.Parser',
    './ResultsVizWidget.UserParser',
    './ResultsVizWidget.Plotter',
    'plotly-js/plotly.min',
    'd3',
    'q',
    'css!./styles/ResultsVizWidget.css'
], function (
    PlotHtml,
    BlobClient,
    Parser,
    UserParser,
    Plotter,
    Plotly,
    d3,
    Q) {

    var ResultsVizWidget,
	WIDGET_CLASS = 'results-viz';

    ResultsVizWidget = function (options) {
        this._logger = options.logger.fork('Widget');

        this._el = options.container;

	this._blobClient = new BlobClient({logger: options.logger.fork('BlobClient')});
	this._client = options.client;

        this._initialize();

        this._logger.debug('ctor finished');
    };

    ResultsVizWidget.prototype._initialize = function () {
        var width = this._el.width(),
            height = this._el.height(),
            self = this;

        this.nodes = {};
	this.plotIDs = [];
        this.alignLogs = true;

        // set widget class
        this._el.addClass(WIDGET_CLASS);
    };

    ResultsVizWidget.prototype._addSplitPanelToolbarBtns = function(toolbarEl) {
        var self = this;

        // BUTTON EVENT HANDLERS

        var enableAlignmentEl = [
            '<span id="enableAlignment" class="split-panel-toolbar-btn fa fa-toggle-on">',
            '</span>',
        ].join('\n');

        var disableAlignmentEl = [
            '<span id="disableAlignment" class="split-panel-toolbar-btn fa fa-toggle-off">',
            '</span>',
        ].join('\n');

        toolbarEl.append(enableAlignmentEl);
        toolbarEl.append(disableAlignmentEl);

        toolbarEl.find('#enableAlignment').on('click', function(){
            self.alignLogs = true;
            var id = Object.keys(self.nodes)[0];
            self.updateNode( self.nodes[id] );
        });

        toolbarEl.find('#disableAlignment').on('click', function(){
            self.alignLogs = false;
            var id = Object.keys(self.nodes)[0];
            self.updateNode( self.nodes[id] );
        });
    };

    ResultsVizWidget.prototype.onWidgetContainerResize = function (width, height) {
        //console.log('Widget is resizing...');
	var self = this;
	this.plotIDs.map(function(plotID) {
	    var n = d3.selectAll(self._el).select(plotID).node();
	    if (n && $(self._el).find(plotID).css('display') != 'none')
		Plotly.Plots.resize(n);
	});
    };

    // Adding/Removing/Updating items
    ResultsVizWidget.prototype.addNode = function (desc) {
	var self = this;
        if (desc && !self.nodes[desc.id]) {
	    var datas = {};
	    desc.logs = {};
	    desc.displayNames = {};

	    var hidePlotFunc = function(a) {
		var active = datas[a].active ? false : true;
		var opacity = active ? 0 : 1;
		var visibility = active ? 'hidden' : 'visible';
		var display = active ? 'none' : 'block';
		self._el.find('#plot_'+a)
		    .css('display', display);
		datas[a].active = active;
	    };

	    var attributes = desc.attributes.concat(desc.userLogs);
	    var timeBeginEnd = {
		begin: -1,
		end: -1
	    };
	    var tasks = attributes.map((key) => {
		var a = key;
		// load the attribute
		var nodeObj = self._client.getNode(desc.id);
		var logHash = nodeObj.getAttribute(a);
		if (logHash) {
		    return self._blobClient.getObjectAsString(logHash)
			.then((data) => {
			    desc.logs[a] = data;
			    // parse the logs
			    var parsed = Parser.getDataFromAttribute(data);
			    if (_.isEmpty(parsed))
				parsed = UserParser.getDataFromAttribute(data);
			    datas[a] = parsed;
			    // figure out time range
			    if (!_.isEmpty(parsed)) {
				var logTimeRange = UserParser.getTimeBeginEnd( datas[a] );
				if (timeBeginEnd.begin == -1 || timeBeginEnd.begin > logTimeRange.begin) {
				    timeBeginEnd.begin = logTimeRange.begin;
				}
				if (timeBeginEnd.end == -1 || timeBeginEnd.end < logTimeRange.end) {
				    timeBeginEnd.end = logTimeRange.end;
				}
			    }
			    // now get the metadata for the display name
			    return self._blobClient.getMetadata(logHash);
			})
			.then((metadata) => {
			    // get the name of the file <node>.<comp>.<user/trace>.log
			    desc.displayNames[a] = metadata.name;
			});
		}
	    });
	    return Q.allSettled(tasks)
		.then(() => {
		    //console.log(timeBeginEnd);
		    var sortedLogs = Object.keys(desc.logs).sort();
		    sortedLogs.map(function(a) {
			// setup the html
			self._el.append(PlotHtml);
			var container = self._el.find('#log');
			container.attr('id', 'log_'+a);
			
			var title = self._el.find('#title');
			var displayTitle = desc.displayNames[a];
			displayTitle = displayTitle.replace(/\.user\.log/gm, ' User Log');
			displayTitle = displayTitle.replace(/\.trace\.log/gm, ' Trace Log');
			displayTitle = displayTitle.replace(/\./gm, '::');

			title.attr('id','title_'+a)
			    .on('click', function(_a) {
				return function() {
				    self._onClick(desc.id);
				    hidePlotFunc(_a);
				};
			    }(a));

			title.append('<b>'+displayTitle+'</b>');

			var p = self._el.find('#plot');
			p.attr('id',"plot_" + a);
			p.click(function() {
			    self._onClick(desc.id);
			});

			var data = datas[a];
                        if (self.alignLogs) {
			    data = UserParser.alignLogs(data, timeBeginEnd.begin, timeBeginEnd.end );
                        }
			if (!_.isEmpty(data)) {
			    Plotter.plotData(self._el, 'plot_'+a, data, self._onClick.bind(self, desc.id) );
			    self.plotIDs.push('#plot_'+a);
			}
			else {
			    container.detach();
			}
		    });
		    self.nodes[desc.id] = desc;
		});
        }
    };

    ResultsVizWidget.prototype.removeNode = function (gmeId) {
        var desc = this.nodes[gmeId];
	if (desc) { // if this is our results object
	    this._el.empty();
            delete this.nodes[gmeId];
	}
    };

    ResultsVizWidget.prototype.updateNode = function (desc) {
	if (this.nodes[desc.id]) { // if this is our results object
	    // remove old data
	    this.removeNode(desc.id);
	    // recreate with new data
	    this.addNode(desc);
        }
    };

    ResultsVizWidget.prototype._onClick = function (id) {
	this.onActivate();
	WebGMEGlobal.State.registerActiveSelection([id]);
    };

    /* * * * * * * * Visualizer event handlers * * * * * * * */

    ResultsVizWidget.prototype.onBackgroundDblClick = function () {
    };

    /* * * * * * * * Visualizer life cycle callbacks * * * * * * * */
    ResultsVizWidget.prototype.clearNodes = function() {
        if (this._el) {
            this._el.empty();
        }
        delete this.nodes;
        this.nodes = {};
    };

    ResultsVizWidget.prototype.shutdown = function() {
        if (this._el) {
            this._el.remove();
            delete this._el;
        }
    };
        
    ResultsVizWidget.prototype.destroy = function () {
        this.clearNodes();
        this.shutdown();
    };

    ResultsVizWidget.prototype.onActivate = function () {
    };

    ResultsVizWidget.prototype.onDeactivate = function () {
        this.clearNodes();
        this.shutdown();
    };

    return ResultsVizWidget;
});
